#!/usr/bin/env python3
"""
Wrapper script that runs Gazelle in two passes with proto import fixes for Bazel 8.
1. First pass: Standard Gazelle generates proto_library rules
2. Fix imports: Remove rules_proto imports for Bazel 8 compatibility
3. Second pass: Protolake extension generates service bundle rules

Usage:
    bazel run //tools:gazelle_wrapper [-- gazelle_args...]

This is equivalent to:
    bazel run //:gazelle [-- gazelle_args...]
    python3 tools/fix_proto_imports.py
    bazel run //:gazelle-protolake
"""

import os
import subprocess
import sys

def run_command(cmd, cwd=None):
    """Run a command and return its exit code."""
    print(f"Running: {' '.join(cmd)}")
    try:
        result = subprocess.run(cmd, cwd=cwd, capture_output=True, text=True)
        if result.stdout:
            print(result.stdout)
        if result.stderr:
            print(result.stderr, file=sys.stderr)
        return result.returncode
    except Exception as e:
        print(f"Error running command: {e}", file=sys.stderr)
        return 1

def run_fix_imports(workspace_root):
    """Run the import fixer Python script directly."""
    print("\nFixing proto imports for Bazel 8 compatibility...")

    # Find the fix_proto_imports.py script
    # When run via bazel run, we might be in a different directory
    possible_paths = [
        os.path.join(workspace_root, "tools", "fix_proto_imports.py"),
        os.path.join(os.getcwd(), "tools", "fix_proto_imports.py"),
        # If we're in bazel-bin
        os.path.join(os.path.dirname(os.path.realpath(__file__)), "fix_proto_imports.py"),
    ]

    fix_script = None
    for path in possible_paths:
        if os.path.exists(path):
            fix_script = path
            break

    if not fix_script:
        print("❌ Fix script not found in any of these locations:", file=sys.stderr)
        for path in possible_paths:
            print(f"  - {path}", file=sys.stderr)
        return 1

    print(f"Found fix script at: {fix_script}")

    # Run Python directly to avoid Bazel parsing BUILD files
    fix_cmd = [sys.executable, fix_script]

    # Set the BUILD_WORKSPACE_DIRECTORY for the script
    env = os.environ.copy()
    env['BUILD_WORKSPACE_DIRECTORY'] = workspace_root

    result = subprocess.run(fix_cmd, cwd=workspace_root, env=env, capture_output=True, text=True)
    if result.stdout:
        print(result.stdout)
    if result.stderr:
        print(result.stderr, file=sys.stderr)

    return result.returncode

def main():
    """Main entry point."""
    # Get workspace root
    workspace_root = os.environ.get('BUILD_WORKSPACE_DIRECTORY', '.')

    # If not set, try to find it by looking for MODULE.bazel
    if workspace_root == '.':
        current = os.getcwd()
        while current != '/':
            if os.path.exists(os.path.join(current, 'MODULE.bazel')):
                workspace_root = current
                break
            current = os.path.dirname(current)

    print("=== Proto Lake Gazelle Wrapper ===")
    print("This script runs Gazelle in two passes with Bazel 8 fixes")
    print(f"Workspace root: {workspace_root}")
    print("")

    # Pass 1: Run standard Gazelle to generate proto_library rules
    print("Pass 1: Running standard Gazelle to generate proto_library rules...")
    gazelle_args = ["bazel", "run", "//:gazelle"]

    # Pass through any additional arguments to the first pass only
    if len(sys.argv) > 1:
        gazelle_args.extend(["--"] + sys.argv[1:])

    exit_code = run_command(gazelle_args, cwd=workspace_root)
    if exit_code != 0:
        print("❌ Standard Gazelle failed!", file=sys.stderr)
        return exit_code

    print("\n✅ Pass 1 completed successfully")

    # Fix imports: Run the import fixer directly as Python
    exit_code = run_fix_imports(workspace_root)
    if exit_code != 0:
        print("❌ Import fixing failed!", file=sys.stderr)
        return exit_code

    print("\n✅ Proto imports fixed successfully")

    # Pass 2: Run Gazelle with protolake extension for service bundles
    print("\nPass 2: Running Gazelle with protolake extension for service bundles...")
    # Use the separate gazelle-protolake target which only has protolake language
    protolake_args = ["bazel", "run", "//:gazelle-protolake"]

    exit_code = run_command(protolake_args, cwd=workspace_root)
    if exit_code != 0:
        print("❌ Protolake Gazelle failed!", file=sys.stderr)
        return exit_code

    print("\n✅ Pass 2 completed successfully")
    print("\nAll BUILD files have been generated and are Bazel 8 compatible!")
    print("- Proto library rules generated by standard Gazelle")
    print("- Service bundle rules generated by protolake extension")

    # Fix imports again: Run the import fixer one more time
    # in case protolake extension created any new BUILD files
    exit_code = run_fix_imports(workspace_root)
    if exit_code != 0:
        print("❌ Final import fixing failed!", file=sys.stderr)
        return exit_code

    print("\n✅ Final proto imports fixed successfully")

    return 0

if __name__ == '__main__':
    sys.exit(main())