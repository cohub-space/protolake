#!/usr/bin/env bash
#
# protolakew - Proto Lake Wrapper
# Generated by Proto Lake. Do not edit manually.
#
# Usage: ./protolakew <command> [options]
#   Commands: build, validate, create-bundle
#
#   Docker flags:
#     --pull MODE              Docker pull policy: missing (default), always, never
#
#   Local install flags:
#     --js-target PATH         Target JS/TS project for workspace install (repeatable, sets NPM_PUBLISH_MODE=workspace)
#
#   Remote publishing flags (override env vars):
#     --maven-repo URL         Maven registry URL (sets MAVEN_REPO)
#     --pypi-repo URL          PyPI registry URL (sets PYPI_REPO)
#     --npm-registry-url URL   npm registry URL (sets NPM_REGISTRY_URL + NPM_PUBLISH_MODE=registry)
#     --registry-token TOKEN   Bearer token for registry auth (sets REGISTRY_TOKEN)
#
set -euo pipefail

LAKE_NAME="{lakeName}"
LAKE_PREFIX="{lakePrefix}"
PROTOLAKE_IMAGE="${PROTOLAKE_IMAGE:-ghcr.io/cohub-space/protolake:latest}"
DOCKER_PULL="missing"

# Compute the Docker mount target to match LakeUtil.getLocalPath()
if [ -n "$LAKE_PREFIX" ]; then
    MOUNT_TARGET="/proto-lake/${LAKE_PREFIX}/${LAKE_NAME}"
else
    MOUNT_TARGET="/proto-lake/${LAKE_NAME}"
fi

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
JS_TARGET_PATHS=()

# Build docker run arguments
DOCKER_ARGS=(
    --rm
    -v "${SCRIPT_DIR}:${MOUNT_TARGET}"
    -v "protolake-cache-${LAKE_NAME}:/home/protolake/.cache/bazel"
    -e "PROTO_LAKE_BASE_PATH=/proto-lake"
)

# Mount local package repositories for install-local
if [ -d "${HOME}/.m2" ]; then
    DOCKER_ARGS+=(-v "${HOME}/.m2:/home/protolake/.m2")
fi
if [ -d "${HOME}/.cache/pip" ] || mkdir -p "${HOME}/.cache/pip"; then
    DOCKER_ARGS+=(-v "${HOME}/.cache/pip:/home/protolake/.cache/pip")
fi

# NPM packages directory
PROTO_LAKE_DIR="${HOME}/.proto-lake"
mkdir -p "${PROTO_LAKE_DIR}/npm-packages" 2>/dev/null || true
DOCKER_ARGS+=(-v "${PROTO_LAKE_DIR}/npm-packages:/home/protolake/.proto-lake/npm-packages")

# SQLite database
mkdir -p "${PROTO_LAKE_DIR}" 2>/dev/null || true
DOCKER_ARGS+=(-v "${PROTO_LAKE_DIR}/protolake.db:/home/protolake/.proto-lake/protolake.db")

# Parse CLI flags that map to env vars (must happen before env var passthrough)
PASSTHROUGH_ARGS=()
while [ $# -gt 0 ]; do
    case "$1" in
        --maven-repo)
            MAVEN_REPO="$2"
            shift 2
            ;;
        --pypi-repo)
            PYPI_REPO="$2"
            shift 2
            ;;
        --npm-registry-url)
            NPM_REGISTRY_URL="$2"
            NPM_PUBLISH_MODE="registry"
            shift 2
            ;;
        --registry-token)
            REGISTRY_TOKEN="$2"
            shift 2
            ;;
        --pull)
            DOCKER_PULL="$2"
            shift 2
            ;;
        --js-target)
            JS_TARGET_PATHS+=("$2")
            shift 2
            ;;
        *)
            PASSTHROUGH_ARGS+=("$1")
            shift
            ;;
    esac
done

# Handle --js-target: resolve paths, set up Docker mounts
if [ ${#JS_TARGET_PATHS[@]} -gt 0 ]; then
    NPM_PUBLISH_MODE="workspace"
    RESOLVED_JS_TARGETS=()
    for js_path in "${JS_TARGET_PATHS[@]}"; do
        abs="$(cd "$js_path" 2>/dev/null && pwd)" || {
            echo "ERROR: --js-target path not found: $js_path" >&2; exit 1
        }
        DOCKER_ARGS+=(-v "${abs}:${abs}")
        RESOLVED_JS_TARGETS+=("${abs}")
    done
    JS_TARGETS_JOINED=$(IFS=,; echo "${RESOLVED_JS_TARGETS[*]}")
    DOCKER_ARGS+=(-e "JS_TARGETS=${JS_TARGETS_JOINED}")
fi

# Pass through environment variables for publishing
# Defaults are local paths; CLI flags and env vars override with registry URLs for remote publish
DOCKER_ARGS+=(
    -e "NPM_PUBLISH_MODE=${NPM_PUBLISH_MODE:-skip}"
    -e "MAVEN_REPO=${MAVEN_REPO:-/home/protolake/.m2/repository}"
    -e "PYPI_REPO=${PYPI_REPO:-/home/protolake/.cache/pip/simple}"
)

# Pass through registry credentials if set
if [ -n "${REGISTRY_TOKEN:-}" ]; then
    DOCKER_ARGS+=(-e "REGISTRY_TOKEN=${REGISTRY_TOKEN}")
fi
if [ -n "${NPM_REGISTRY_URL:-}" ]; then
    DOCKER_ARGS+=(-e "NPM_REGISTRY_URL=${NPM_REGISTRY_URL}")
fi
if [ -n "${NPM_REGISTRY_TOKEN:-}" ]; then
    DOCKER_ARGS+=(-e "NPM_REGISTRY_TOKEN=${NPM_REGISTRY_TOKEN}")
fi

# Pass through Gazelle configuration if set
if [ -n "${PROTOLAKE_GAZELLE_SOURCE_PATH:-}" ]; then
    DOCKER_ARGS+=(
        -v "${PROTOLAKE_GAZELLE_SOURCE_PATH}:/opt/protolake-gazelle"
        -e "PROTOLAKE_GAZELLE_SOURCE_PATH=/opt/protolake-gazelle"
    )
elif [ -n "${PROTOLAKE_GAZELLE_GIT_URL:-}" ]; then
    DOCKER_ARGS+=(-e "PROTOLAKE_GAZELLE_GIT_URL=${PROTOLAKE_GAZELLE_GIT_URL}")
    if [ -n "${PROTOLAKE_GAZELLE_GIT_COMMIT:-}" ]; then
        DOCKER_ARGS+=(-e "PROTOLAKE_GAZELLE_GIT_COMMIT=${PROTOLAKE_GAZELLE_GIT_COMMIT}")
    fi
    if [ -n "${PROTOLAKE_GAZELLE_GIT_TAG:-}" ]; then
        DOCKER_ARGS+=(-e "PROTOLAKE_GAZELLE_GIT_TAG=${PROTOLAKE_GAZELLE_GIT_TAG}")
    fi
fi

# Pass through VERSION if set
if [ -n "${VERSION:-}" ]; then
    DOCKER_ARGS+=(-e "VERSION=${VERSION}")
fi

# Pass through Bazel config profile (e.g., "ci" to activate remote cache)
if [ -n "${PROTOLAKE_BAZEL_CONFIG:-}" ]; then
    DOCKER_ARGS+=(-e "PROTOLAKE_BAZEL_CONFIG=${PROTOLAKE_BAZEL_CONFIG}")
fi

# Pass through GCP credentials for GCS remote cache
if [ -n "${GOOGLE_APPLICATION_CREDENTIALS:-}" ]; then
    DOCKER_ARGS+=(
        -v "${GOOGLE_APPLICATION_CREDENTIALS}:/tmp/gcloud-credentials.json:ro"
        -e "GOOGLE_APPLICATION_CREDENTIALS=/tmp/gcloud-credentials.json"
    )
fi

# Pass through Bazel timeout (default: 1200s for cold builds with gRPC C++ compilation)
DOCKER_ARGS+=(-e "PROTOLAKE_BAZEL_TIMEOUT_SECONDS=${PROTOLAKE_BAZEL_TIMEOUT_SECONDS:-1200}")

exec docker run --pull "${DOCKER_PULL}" "${DOCKER_ARGS[@]}" "${PROTOLAKE_IMAGE}" "${PASSTHROUGH_ARGS[@]}"
